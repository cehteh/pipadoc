pipadoc - Documentation extractor
=================================
:author:   Christian Thaeter
:email:    ct@pipapo.org
:date:     22. August 2020


[preface]
Introduction
------------

Embedding documentation in program source files often results in the problem that the
structure of a program is not the optimal structure for the associated documentation.
Still there are many good reasons to maintain documentation together with the source right
within the code which defines the documented functionality. Pipadoc addresses this problem
by extracting special comments out of a source file and let one define rules how to compile
the documentation into proper order.  This is somewhat similar to ``literate Programming''
but it puts the emphasis back to the code.

Pipadoc is programming language and documentation system agnostic, all it requires is that
the programming language has some form of comments starting with a defined character sequence
and spanning to the end of the source line. Moreover documentation parts can be written in
plain text files aside from the sources.


History
-------

This 'pipadoc' implemented in Lua follows an earlier implementation with a slightly different
(incompatible) syntax and less features which was implemented in AWK. Updating to the new
syntax should be straightforward and is suggested for any projects using pipadoc.


Getting the Source
------------------

Pipadoc is managed the git revision control system. You can clone the repository with

 git clone --depth 1 git://git.pipapo.org/pipadoc

The 'master' branch will stay stable and development will be done on the 'devel' branch.


Installation
------------

Pipadoc is single Lua source file `pipadoc.lua` which is portable among most Lua versions
(PUC Lua 5.1, 5.2, 5.3, Luajit, Ravi). It ships with a `pipadoc.install` shell script which
figures a suitable Lua version out and installs `pipadoc.lua` as `pipadoc` in a given
directory (the current directory by default).

There are different ways how this can be used in a project:

- When a installed Lua version is known from the build tool chain one can include the
  `pipadoc.lua` into the project and call it with the known Lua interpreter.
- One can rely on a pipadoc installed in '$PATH' and just call that from the build tool chain
- One could ship the `pipadoc.lua` and `pipadoc.install` and do a local install in the build
  directory and use this pipadoc thereafter.


Usage
-----

Pipadoc is called with options and all input files. It may read a configuration file. When
generating output it is either send to _stdout_ or saved as a given output file.

.....
 pipadoc [options...] [inputs..]
   options are:
     -v, --verbose
                         increment verbosity level
 
     -q, --quiet
                         suppresses any messages
 
     -d, --debug
                         set verbosity to debug level
                         one additional -v enables tracing
 
     -n, --dry-run
                         don not generate output
 
     -h, --help
                         show this help
 
     -r, --register <name> <file> <comment>
                         register a filetype pattern
                         for files matching a file pattern
 
     -t, --toplevel <name>
                         sets 'name' as toplevel node [MAIN]
 
     -c, --config <name>
                         selects a config file [pipadoc_config.lua]
 
     --no-defaults
                         disables default filetypes and configfile loading
 
     -m, --markup <name>
                         selects the markup engine for the output [text]
 
     -o, --output <file>
                         writes output to 'file' [stdout]
 
     -a, --alias <pattern> <as>
                         aliases filenames to another filetype.
                         for example, treat .install files as shell files:
                          --alias '(.*)%.install' '%1.sh'
 
     -D, --define <name>[=<value>]
                         define a GLOBAL variable to value or 'true'
     -D, --define -<name>
                         undefine a GLOBAL variable
 
     -P, --define-post <name>[=<value>]
                         define a GLOBAL_POST variable to value or 'true'
     -P, --define-post -<name>
                         undefine a GLOBAL_POST variable
 
     --
                         stops parsing the options and treats each
                         following argument as input file
 
   inputs are file names or a '-' that indicates standard input
.....


Basic concepts
--------------

Pipadoc is controlled by special line comments. This is chosen because it is the most common
denominator between almost all programming languages.

To make a line comment recognized as pipadoc comment it needs to be followed immediately
by a operator sequence. Which in the simplest case is just a single punctuation character.
These operator sequences can define the section to which this comment belongs to.

To add special functionality and extend the semantics one can define pre and post processors.
Preprocessors are defined per input programming language and process all source lines. They can
modify the source arbitrary before pipadoc does the parsing. This allows to generate completely
new content. Lift parts on the source code side over to the documentation and generate
additional information such as indices and glossaries.
Postprocessors are defined for output markup and process every line in output order. The allow
to augment output in a markup specific way.

There is a string substitution/template engine which can processes text.


Example
~~~~~~~

Without further ado, here is a slightly terse example showing pipadoc documentation on a
shell script. For a more complex example one could look at 'pipadoc.lua' itself. The exact
pipadoc syntax is described in the next section.

.An example document (example.sh)
----
#!/bin/sh
#: here the default section is 'example', derived from 'example.sh'
#oneline:o this is appended to the section 'oneline' under key 'o'
#: back to the 'example' section
#newname:
#: this starts a new section block named 'newname'
#oneline:a this is appended to the section 'oneline' under key 'a'
#MAIN:
#: Assemble the document
#: first the 'newname'
#=newname
#: then 'example'
#=example
#: and finally 'oneline' alphabetically sorted by keys
#@oneline
----

processed by pipadoc
....
lua pipadoc.lua -- example.sh
....

Will result in
----
Assemble the document
first the 'newname'
this starts a new section block named 'newname'
then 'example'
here the default section is 'example', derived from 'example.sh'
back to the 'example' section
and finally 'oneline' alphabetically sorted by keys
this is appended to the section 'oneline' under key 'a'
this is appended to the section 'oneline' under key 'o'
----


Syntax
~~~~~~

.In short:
A pipadoc comment is any 'line-comment' of the programming language directly (without spaces)
followed by a optional alphanumeric section name which may have a sorting key appended by
a dot, followed by an operator, followed by an optional argument. Possibyl followed by the
documentation text itself.

Only lines qualify this syntax are processed as pipadoc documentation. But preprocessors run
before the parsing is done and may translate otherwise non pipadoc sourcecode into documentation.

.The formal syntax looks like:
....
<pipadoc> ::= [source] <linecomment> <opspec> [ <space> [documentationtext]]

<source> ::= <any source code text>

<linecomment> ::= <the filetypes linecomment sequence>

<opspec> ::= [section['.'key]] <operator> [argument]

<section> ::= <alphanumeric text including underscore>

<operator> ::= ":" | "+" | "=" | "@" | "$" | "#" | <user defined operators>

<key> ::= <alphanumeric text including underscore>

<argument> ::= <alphanumeric text including underscore>

<documentationtext> ::= <rest of the line>
....

IMPORTANT: Pipadoc does not know anything except the line comment characters about the source
           programming languages syntax. This includes literal strings and any other
           syntactic form which may look like a line comment, but is not. Such lines need to
           be dropped by a preprocessor to make them unambiguous.
           There config shipped with pipadoc gives an example to drop a line when it end with
          "NODOC".

Documentation can be either in blocks or single lines.

Block::
  Start with a documentation comment including a section or argument specifier but are not
  followed by documentation text on the same line.
  The text block then follows in documentation comments where section and
  argument are empty. Blocks span until a new documentation block is started.
One Line::
  Is defined by a documentation comment which sets section and/or argument followed by
  documentation text on the same line. They can be interleaved within blocks.
  This is used to define index and glossary items right within block documentation.


Sections and Keys
-----------------

Text in pipadoc is stored in named 'sections'. Text can be associated with some
alphanumeric key under that section. This enables later sorting for indices and glossaries.

One-line sections are defined when a section and maybe a key is followed by documentation
text. Block sections start with the section definition but no documentation text on the same
line. A block stays active until the next block section definition. One-line doctext can be
interleaved into Blocks.

The default block section name is the files name up, but excluding to the first dot.

Sections are later brought into the desired order by pasting them into a 'toplevel' section.
This default name for the 'toplevel' section is 'MAIN_{markup}' or if that does not exist
just 'MAIN'.



Order of operations
~~~~~~~~~~~~~~~~~~~

Pipadoc reads all files line by line. and processes them in the following order:

Preprocessing ::
  Preprocessors are Lua functions who may alter the entire content of a line before any
  further processing. They get a 'context' table passed in with the 'SOURCE' member
  containing the line read from the input file.

Parsing ::
  The line is broken down into its components and the operators processing function
  will be called. The ':' and '+' operators do a first string substitution pass to
  expand variables. This string substitution is done in input order.
  String substitution macros may leverage this for additional state and may generate
  extra content like indices and append that to the respective sections.

Output Ordering ::
  The output order is generated by assembling the '{toplevel}_{markup}' or if that does
  not exist the '{toplevel}' section.
  The paste and sorting operators there define the section order of the document.

Postprocessing ::
  For each output context the postprocessors run in output order.
  Finally a last string substitution pass is applied in output order.
  This pass can generate markup specific changes.

Writeout ::
  The finished document is written to the output.

Report empty sections, Orphans and Doubletes::
  Pipadoc keeps stats on how each section was used. Finally it gives a report (as warning)
  on sections which appear to be unused or used more than once. These warnings may be ok, but
  sometimes they give useful hints about typing errors.

It is important to know that reading happens only line by line, operations can not span
lines. While Processing steps can be stateful and thus preserve information for further
processing.


Filetypes
---------

Pipadoc needs to know about the syntax of line comments of the files it is reading.
For this patterns are registered to be matched against the file name together with a
list of line comment characters.

Definitions for a common programming languages are already included. For languages
that support block comments the opening (but not the closing) commenting characters are
registered as well. This allows one to define section blocks right away. But using the
comment closing sequence right on the line would clobber the output.

.Example in C
----
/*blocksection:
//: this is a block-section
//: line comment sequences inside the block comment are still required
*/

/*works_too: but looks ugly
*/

// the following will include the closing */ in the documentation
/*fail: don't do this, pipadoc comments span to the end of the line */
----

A special case is that when a line comment is defined as an empty string ("") then every
line of a file is considered as documentation but no special operations apply. This is used
for plain text documentation files. These use the "PIPADOC:" keyword to enable special
operations within text files.

New filetypes can be added from a config file with 'filetype_register()'  or with
the '--register' command-line option.


.Predefined Filetypes

Autoconf, Automake,
AWK,
C, C++, Headerfiles,
CMake,
Delphi, Pascal,
Java, C#,
Javascript,
Lua,
Makefiles,
Objective-C,
Perl,
PHP,
Prolog,
Python,
Ruby,
SCons,
Shell,
SQL,
Textfiles, Pipadoc (`.pdoc`),
Visual Basic,


Markup Languages
----------------

The core of pipadoc is completely agnostic about the markup used within the documentation strings.
The '--markup' option only sets the 'MARKUP' variable and output generation tries include the
markup in the toplevel. Usually only string substitution and postprocessors shoould handle markup
related things.

The shipped configuration file comes with postprocessors for 'asciidoc' and 'text' markups.


Operators
---------

Operators define what is considered as pipadoc comment and how to assemble the resulting document.
The default operators either store text or paste (possibly sorted) text.

`:` ::
  The documentation operator. Defines normal documentation text. Each pipadoc comment using
  the `:` operator is processed as documentation. Later when generating the toplevel
  Section is used to paste all other documentation in proper order together.

`+` ::
  Concat operator. Like ':' but appends text at the last line instead creating a new line.
  Note that some context information (file/line) gets lost as only the text will be appended.

`=` ::
  Section paste operator. Takes a section name as argument and will paste that section in
  place.

`@` ::
  Alphabetic sorting operator. Takes a section name as argument and will paste section
  text alphabetically sorted by its keys.

`$` ::
  Generic sorting operator. Takes a section name as argument and will paste section text
  sorted by its keys.

`#` ::
  Numerical sorting operator. Takes a section name as argument and will paste section text
  numerically sorted by its keys.



Configuration File
------------------

Pipadocs main objective is to scrape documentation comments from a project and generate
output in desired order. Such an basic approach would be insufficient for many common cases.
Thus pipadoc has pre and postprocessors and the string substitution engine to generate and
modify documentation in an extensible way.

Pipadoc tries to load a configuration file on startup. By default it is named
+pipadoc_config.lua+ in the current directory. This name can be changed with the
'--config' option.

The configuration file is used to define pre- and post- processors, define states
for those, define custom operators and string substitution macros. It is loaded and
executed as it own chunk and may only access the global variables and
API functions described below.

Without a configuration file none of these processors are defined any only few
variables for string substitution engine are set.


Preprocessors
~~~~~~~~~~~~~

One can register preprocessors per filetypes. A preprocessor can modify any line
prior it gets parsed and further processed.

Preprocessors are used to autogenerate documentation comments from code. Lifting
parts of the code to the documentation side.


Postprocessors
~~~~~~~~~~~~~~

Postprocessors run at output generation time. They are registered per markup type.
Processors are called in order of their definition.

They are used to augment the generated output with markup specific things.


String Substitutions
~~~~~~~~~~~~~~~~~~~~

Documentation text is be passed to the string substitution engine which recursively
substitutes macros within curly braces. The substitutions are taken from the passed
context (and GLOBAL's). Strings are replaced, functions become evaluated.

String substitutions names consist alphanumeric characters or underlines.
The names themself can be composed from string substitutions.
It may be followed with a delimiting character (space) and an optional argument string
which gets passed to functions or recursive string substitution. Names starting and ending
with 2 underscores are reserved to the implementation.

The resulting string if a string substitution is subject of further recursive string
substitution. For this substitutions the '+++__ARG__+++' variable is set to the supplied
arguments from the calling context.

When the substitution is a function it takes the arguments as parameter.

Curly braces, can be escaped with backslashes or backtick characters. These
characters can be escaped by themself.

.Example
-----
GLOBAL.SIMPLE = "a simple example"
GLOBAL.BRACED = "{BRACED_{MARKUP} {__ARG__}}"
GLOBAL.BRACED_text = "`{{__ARG__}`}"
GLOBAL.BRACED_asciidoc = "\\`{{__ARG__}\\`}"
-----

.Explanation:
. '{SIMPLE}' would expand to 'a simple example'
. 'BRACED_{MARKUP}' gets expanded to 'BRACED_<markup>', where '<markup>' is the
  defined markup language to use.
. The argument get passed along with '{+++__ARG__+++}'.
. The resulting string from 1. dispatches on the markup language to one of the following.
. 'BRACED_text' defines how the braces are rendered around '+++__ARG__+++' in text markup.
. 'BRACED_asciidoc' does the same for asciidoc output.

NOTE: The escaping rules become a bit complicated because one has to consider the escaping
      rules of all components involved. This is first Lua when assigned in literal strings.
      Second the escaping rules of the string substitution engine itself (curly braces,
      backslashes and backticks). And finally the escaping rules of the targeted markup
      language.


Shipped Configuration File
~~~~~~~~~~~~~~~~~~~~~~~~~~

Pipadoc comes with a configuration file for generating it's own documentation and
assist the test suite. This is a good starting point for writing your own configuration.

This configuration file implements the features explained next.

Preprocessors
^^^^^^^^^^^^^

* Ignore any line which ends in 'NODOC'.
*  Replace '<STRING>' in pipadoc comments with the first literal doublequoted string from the code.
   This lifts string literals from sourcecode to documentation. The doublequotes are removed.
*  Replaces '<HEXSTRING>' in a opspec key with the first literal doublequoted string from the code
   converted to lowercase hexadecimal (useable for sorting including whitespace and punctuation).
   When no literal doublequoted string exists in the code, then the last used hexadecimal
   string is used. Used for sorting documentation by the lifted string literal.
* Automatic generation of documentation for Lua functions.
  Generates an index entry and a prototype header from an one line function definition
* When GLOBAL.ISSUES is defined, generate formatted lists for doc comments in
  WIP/FIXME/TODO/PLANNED/DONE sections.
  When GLOBAL.GIT is defined ('-D GIT') then each such item includes information gathered
  from the git commit which touched that line the last.
  When GLOBAL.NOBUG is defined it reaps http://nobug.pipapo.org[NoBug] annotations from
  C source files as well.

Postprocessors
^^^^^^^^^^^^^^

* Keep track of original file:line as asciidoc comments in the output.
  Disable this tracking when a doc comment starts with 'NOORIGIN' and
  re-enable it with a doc comment starting with 'ORGIN'.

String Substitutions Macros
^^^^^^^^^^^^^^^^^^^^^^^^^^^

* '{BRACED argument}' puts 'argument' in curly braces. Escapes this curly braces
  depending on the markup engine selected.
* '{LUA_FNDEF}' Lifts a Lua function definition to the documentation text.
  Used by the Lua documentation preprocessor.
* '{VARDEF name}' generates a header and index entry for 'name'.
  Used for documentaton of GLOBAL and CONTEXT variables (pipadoc's own documentation).
  Defined for asciidoc and text backends.
* '{INDEX_ENTRY name}' Entry in the index that refers back to 'name'.
* '\{GIT_BLAME}' Insert a 'git blame' report about the current line.
  Refer to the source for details.


External Libraries
~~~~~~~~~~~~~~~~~~

'pipadoc' does not depend on any external Lua libraries. Nevertheless modules can be loaded
optionally to augment the behavior and provide extra features. Plugin-writers should
use the 'request()' function instead the Lua 'require()', falling back to simpler but usable
functionality when some library is not available or call 'die()' when a reasonable fallback
won't do it.

Pipadoc already calls 'request "luarocks.loader"' to make rocks modules available.


Programming API for Extensions
------------------------------


[[GLOBAL]]
Documentation Variables
~~~~~~~~~~~~~~~~~~~~~~~

The 'GLOBAL' and 'GLOBAL_POST' Lua tables holds key/value pairs of variables
with global definitions. These are used by the core, processors and string substitution.
Simple string assignments can be set from the command line. Configuration files may define
more complex Lua functions for string substitutions.


Predefined Variables
^^^^^^^^^^^^^^^^^^^^

The 'GLOBAL' table is initialized with:

YEAR, MONTH, DAY, HOUR, MINUTE:
  Current date information
DAYNAME, MONTHNAME:
  The name of the day of week or month
DATE:
  Current date in YEAR/MONTH/DAY format
LOCALDATE:
  Current date in current locale format
MARKUP:
  The markup syntax (--markup option). This information used by pipadoc
  for selecting the top level section and postprocessors. Other user
  defined extensions may use it as well.
NIL:
  Expands to an empty string.
NL:
  The line-break character sequence, defaults to '\n' and
  can be changed with the '--define' command-line option.

The 'GLOBAL_POST' table is extends 'GLOBAL' and is used for a final string substitution
pass after postprocessing. There are no values defined in 'GLOBAL_POST' by pipadoc itself.

[[CONTEXT]]
The Context
~~~~~~~~~~~

Processors, operators, string substitution calls and diagnostics get a context
passed along. This context represents the parsed line plus
everything that's defined at file level and in GLOBAL (or GLOBAL_POST).

In a few cases a fake-context with FILE name in angle brackets is passed around for
diagnostic functions.

Context Members
^^^^^^^^^^^^^^^

The following members are defined in 'contexts'.

ARG:
  Optional argument to the operator. This can be the sort key
  (alphabetic or numeric) or another section name for pasting.
COMMENT:
  Character sequence which is used as line comment.
FILE:
  The file or section name currently processed or some special annotation
  in angle brackets (eg '<startup>') on other processing phases
COMMENTS_TABLE:
  A Lua table with the all possible line comment character sequences
  for this filetype. Available at preprocessing time before parsing.
KEY:
  Sort key
LANGUAGE:
  The language name of this file.
LINE:
  Current line number of input or section, or indexing key
  Lines start at 1
OP:
  Single punctuation operator defining how to process this line.
PRE:
  Contains the source code in font of the line comment.
SECTION:
  Section where the documentation should appear.
SOURCE:
  The line as read from the input file.
TEXT:
 The actual Documentation Text.


Exported Functions
~~~~~~~~~~~~~~~~~~

pipadoc exports global functions for the use in pre/post processors from config files.


Library Loading
^^^^^^^^^^^^^^^

request(name):
 try to load optional modules
   wraps Lua 'require' in a pcall so that failure to load module 'name' results in 'nil'
   rather than a error.

Logging Progress and Errors
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Functions for to log progress and report errors. All this functions take a variable argument
list. Any argument passed to them will be converted to a string and printed to stderr when
the verbosity level is high enough.

warn(context,...):
 report a important but non fatal failure
dbg(context,...):
 show debugging information
trace(context,...):
 show more detailed progress information
die(context, ...):
 report a fatal error and exit the program

Type Checks
^^^^^^^^^^^

Assertions to check externally supplied data. On success 'var' will be returned
otherwise an assertion error is raised.

assert_type(var, expected):
 checks that the 'var' is of type 'expected'
maybe_type(var, expected):
 checks that the 'var' is of type 'expected' or nil
assert_char(var):
 checks that 'var' is a single character
assert_notnil(var):
 checks that 'var' is not 'nil'

Type Conversions
^^^^^^^^^^^^^^^^

Functions which do specific conversions.

to_table(v):
 if 'v' is not a table then return +++{v}+++
maybe_text(v):
 convert 'v' to a string, returns 'nil' when that string would be empty

String Substitution
^^^^^^^^^^^^^^^^^^^

strsubst(context, str, escape):
 substitute text
  context:::
    The current context which defines all variables and
    macros for the substitution.
  str:::
    The string to operate on.
  escape:::
    Rule for special character escaping.
    true:::: handle escaping in one pass.
    'escape':::: 1st pass, replaces escaped characters with a reserved internal representation.
    'unescape':::: 2nd pass, turns the reserved internal representation of escaped characters back into the native form.
    nil:::: no special escaping.

.Examples
----
context = {
  STRING = "example string",
  STR = "{STRING}",
  ING = "ING",
  UPPER = function(context, arg)
            return arg:upper()
          end
 }

-- simple substitution
assert(strsubst(context, "{STRING}") == "example string")

-- arguments on stringish substitutions are retained
assert(strsubst(context, "{STRING example}") == "example stringexample")

-- substitution is recursively applied
assert(strsubst(context, "{STR}") == "example string")

-- that can be used to create names dynamically
assert(strsubst(context, "{STR{ING}}") == "example string")

-- functions are called with the argument and their return is substituted
assert(strsubst(context, "{UPPER arg}") == "ARG")

-- now together
assert(strsubst(context, "{UPPER {STR}}") == "EXAMPLE STRING")

-- undefined names are kept verbatim
assert(strsubst(context, "{undefined}") == "{undefined}")
----


Filetypes
^^^^^^^^^

filetype_register(name, filep, linecommentseqs):
 Register a new filetype
    name:::
      mnemonic name of the language
    filep:::
      a Lua pattern or list of patterns matching filename
    linecommentseqs:::
      a string or list of strings matching comments of the registered filetype

For example, C and C++ Filetypes are registered like:

----
filetype_register("C",
                  {"%.c$","%.cpp$","%.C$", "%.cxx$", "%.h$"},
                  { "//", "/*"})
----


Operators
^^^^^^^^^

Operators have 2 functions associated. The first one is the processing function that
defines how a documentation comment gets stored. The second one is the generator function
which will emits the documentation at output time.

operator_register(char, procfunc, genfunc):
 Register a new operator
  char:::
    single punctuation character except '.' defining this operator.
  procfunc +function (context)+:::
    a function which receives a CONTEXT table of the current line.
    The procfunc processes and stores the context in appropriate
    fashion (see <<index_section_append,section_append()>>).
  genfunc +function (context, output)+:::
    a function generating the output from given context, appending
    it to the supplied 'output' table.


Preprocessors
^^^^^^^^^^^^^

preprocessor_register(langpat, preprocess):
 register a preprocessor
  langpat:::
    Register preprocessor to all filetypes whose mnemonic matches 'langpat'.
    Matches all languages when 'nil'.
  preprocess:::
    The preprocessor to register. Can be one of:
    `function (context) ... end` ::::
      Preprocessors may store state or have other side effect using API functions.
      Takes the context of the current source line and shall return:
      * the preprocessed line
      * false to drop the line
      * true to keep the line unaltered
    +{pattern, repl [, n]}+ ::::
      Generates a function calling 'context.SOURCE:gsub(pattern, repl [, n])' for preprocessing.


Postprocessors
^^^^^^^^^^^^^^

postprocessor_register(markuppat, postprocess):
 register a postprocessor
  markuppat:::
    Register postprocessor to all markups whose name matches 'markuppat'.
    Matches all markups when 'nil'.
  postprocess:::
    The postprocessor to register. Can be one of:
    `function (context) ... end` ::::
      Postprocessors may store state or have other side effect using API functions.
      Takes the context of the current source line and shall return:
      * the postprocessed line (context.TEXT)
      * false to drop the line
      * true to keep the line unaltered
    +{pattern, repl [, n]}+ ::::
      Generates a function calling 'context.TEXT:gsub(pattern, repl [, n])' for postprocessing.


Sections
^^^^^^^^

section_append(section, key, context):
 Append data to the given section/key
  to be called from preprocessors or macros which generate new content.

  section:::
    name of the section to append to, must be a string
  key:::
    the sub-key for sorting within that section. 'nil' for appending text to normal sections
  context:::
    The source line broken down into its components and additional pipadoc metadata

section_concat(section, key, context):
 Concat data to the given section/key
  to be called from preprocessors or macros which generate new content.

  section:::
    name of the section to append to, must be a string
  key:::
    the sub-key for sorting within that section. 'nil' for appending text to normal sections
  context:::
    The source line broken down into its components and additional pipadoc metadata


Other functions
~~~~~~~~~~~~~~~

pattern_escape(s):
 Escape all characters in string 's' so that it can be used as verbatim pattern.
string_tohex(s):
 Encode a string as sequence of 2-byte hex chars (useable as sorting key)
inputfile_add(filename):
 Add a 'filename' to the list of files to process
alias_register(from, to):
 Register a new filetype alias.
  See '--alias' for an example.
  from:::
    A pattern (possibly with a capture) matching unknown input filenames.
  to:::
    The replacement (possibly expanding the capture) to a known aliased filetype.

context_new(parent, new):
 Create a new context.
Used whenever preprocessors/macros need to generate new content.
  parent:::
    The parent context to extend from.
  new:::
    A table (or nil) containing the additional members for the
    new context.


[appendix]
Common Errors and Warnings
--------------------------

Pipadoc emits warnings on problems. Even with warnings processing will usually go on but
the output may need some attention.
Warnings are suppressed with the '--quiet' option.

alias pattern error ::
 The pattern for a file alias is invalid.
ARG and KEY defined in store operator ::
 The store operators ':' and '+' must either be 'section<op>key' or 'section.key<op>' but not 'section.key<op>key'.
can't load config file ::
 The config file ('--config' option) could not be loaded.
can't load module ::
 'request()' failed to load a module.
failed to open ::
 Output file could not be opened.
file not found ::
 A given file can not be opened (wrong path or typo?).
generator failed ::
 error in operators generator function.
input file given twice ::
 Ignored a file given multiple times for input.
no keys in section ::
 The given section has no key entries but should be sorted.
no such section ::
 The given section is not defined.
operator processing failed ::
 Error executing a operators processor.
paste argument missing ::
 Using the '=' operator without an argument.
postprocessor failed ::
 Postprocessor function error.
postprocessor returned wrong type ::
 Postprocessor returned unsupported type (or nil).
preprocessor failed ::
 Preprocessor function error.
preprocessor returned wrong type ::
 Preprocessor returned unsupported type (or nil).
recursive paste ::
 Pasted sections (see <<_built_in_operators,paste operator>>) can not recursively
 include themself.
section is empty ::
 Tried to paste ('=') an empty section.
section is empty ::
 Trying to sort a section by keys yield zero results.
section key multiple times used ::
 Section was used multiple times in the output (sorting operators).
section key unused ::
 Section with keys (numeric or alphabetic) was not used.
section multiple times used ::
 Section was used multiple times in the output.
section unused ::
 The printed section was not used. This might be intentional when generating
 only partial outputs.
sort argument missing ::
 Using the '@', '$' or '#' operator without an argument.
strsubst function failed ::
 Tried to call a custom function from 'strsubst()' which failed.
strsubst no expansion ::
 No substitution defined. Braced expression left verbatim.
strsubst type error ::
 strsubst() expects a string or a function for expansion.
toplevel section undefined ::
 The section used as root for the output generation is not defined.
unknown file type ::
 The type of the given file was not recognized (see <<_usage,'--register'>> option).
unsupported postprocessor type ::
 Tried to 'postprocessor_register()' something that is not a function or table.
unsupported preprocessor type ::
 Tried to 'preprocessor_register()' something that is not a function or table.

[appendix]
Generate the Pipadoc Documentation
----------------------------------

'pipadoc' documents itself with embedded asciidoc text. This can be extracted with

----
lua pipadoc.lua -m asciidoc pipadoc.lua pipadoc_config.lua -o pipadoc.txt
----

The resulting `pipadoc.txt` can then be processed with the asciidoc tool chain to produce
distribution formats:

----
# generate HTML
asciidoc -a toc pipadoc.txt

# generate PDF
a2x -L -k -v --dblatex-opts "-P latex.output.revhistory=0" pipadoc.txt
----

For convenience there is a '--make-doc' option which calls the above commands.


[appendix]
GNU General Public License
--------------------------

----
pipadoc - Documentation extractor
Copyright (C)                        Pipapo Project
 2015, 2016, 2017, 2020              Christian Thaeter <ct@pipapo.org>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----

License Explanation
~~~~~~~~~~~~~~~~~~~

The License (GPLv3) only applies to pipadoc and any derivative work. The purpose of pipadoc
is to extract documentation from other files, this does not imply that these source files
from which the documentation is extracted need to be licensed under the GPL, neither does
this imply that the extracted documentation need to be licensed under the GPL.

The GPL applies when you distribute pipadoc itself, in original or modified form. Since
pipadoc is written in the Lua scripting language, you already distribute its source as well,
which naturally makes this distribution conform with the GPL.

Nevertheless, when you make any improvements to pipadoc please consider to contact
Christian Thäter <ct@pipapo.org> for including them into the mainline.

